---
title: ðŸ’¬ Command CustomId Codec
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The `CommandCustomIdCodec` is the object responsible for encoding and decoding command custom ids. That is, custom ids
that refer to commands. With this object you can easily create components that will trigger commands when
they are used. It's stored by a `CommandManager`, and you can get it via `CommandManager#getCustomIdCodec()`.

:::danger
It's advised that you only use this API for simple user actions. If you're looking for something more complex,
you should use a dedicated handler or the [ðŸ‘¤ Sessions API](./../sessions/session-overview).
:::

## âœ¨ Examples

:::tip
All serialization methods are public, so you can make command custom ids anywhere, not just inside a command class. 
:::


```mdx-code-block
<Tabs>
<TabItem value="Referring to a command">
```

```ts
class MyCommand extends <Any ExecutableCommand> {
  public async execute(
    interaction: ChatInputCommandInteraction,
    meta: CommandExecutionMeta,
  ) {
    // The bot contains the CustomIdCodec, so we need it first
    const bot = meta.get(TypedKeys.Bot);

    // Get the customId:
    const customId = bot.getCommandManager().getCustomIdCodec().serialize(this.customIdData);
    // Or the shorthand:
    const customId = this.getCustomId(bot);

    // Reply with it
    const button = new ButtonBuilder().setCustomId(customId);
    await interaction.reply({ components: [new ActionRowBuilder().addComponents(button)] });
  }

  protected async handleButton(interaction: ButtonInteraction) {
    await interaction.reply('Pong!');
  }
}
```

```mdx-code-block
</TabItem>
<TabItem value="Referring with extra data">
```

```ts
class MyCommand extends <Any ExecutableCommand> {
  public async execute(
    interaction: ChatInputCommandInteraction,
    meta: CommandExecutionMeta,
  ) {
    // The bot contains the CustomIdCodec, so we need it first
    const bot = meta.get(TypedKeys.Bot);

    // Get the customId:
    const customId = bot.getCommandManager().getCustomIdCodec().serialize(this.customIdData, 'Extra data');
    // Or the shorthand:
    const customId = this.getCustomId(bot, 'Extra data');

    // Reply with it
    const button = new ButtonBuilder().setCustomId(customId);
    await interaction.reply({ components: [new ActionRowBuilder().addComponents(button)] });
  }

  protected async handleButton(interaction: ButtonInteraction, meta: CommandExecutionMeta) {
    const extra = meta.get(TypedKeys.CustomIdExtra);
    await interaction.reply(extra) // Replies 'Extra data';
  }
}
```

```mdx-code-block
</TabItem>
<TabItem value="Passing complex extra data">
```

For passing complex data, we recommend using the [`@sapphire/string-store`](https://www.npmjs.com/package/@sapphire/string-store) package, which will:

- Let you serialize complex schemas, including object unions.
- Compress the result so it can easily fit into Discord's `customId` limit (100 characters).
- Add type-safety in both the serialization and deserialization steps.

```ts
import { Schema, SchemaStore } from '@sapphire/string-store';

const Ids = Object.freeze({
  AgeUpdate: 0,
  StrengthUpdate: 1,
});

const store = new SchemaStore()
  .add(new Schema(Ids.AgeUpdate).int32('age'))
  .add(new Schema(Ids.StrengthUpdate).float32('strength'));

class MyCommand extends <Any ExecutableCommand> {
  public async execute(
    interaction: ChatInputCommandInteraction,
    meta: CommandExecutionMeta,
  ) {
    const bot = meta.get(TypedKeys.Bot);

    // For the age button:
    const ageExtra = store.serialize(Ids.AgeUpdate, {
      age: 20,
    });
    const ageCustomId = this.getCustomId(bot, extra);
    const ageButton = new ButtonBuilder().setCustomId(ageCustomId);

    // For the strength button:
    const strengthExtra = store.serialize(Ids.StrengthUpdate, {
      strength: 1.5,
    });
    const strengthCustomId = this.getCustomId(bot, extra);
    const strengthButton = new ButtonBuilder().setCustomId(strengthCustomId);

    // Aggregate and reply:
    const row = new ActionRowBuilder().addComponents(ageButton, strengthButton);
    await interaction.reply({ components: [row] });
  }

  protected async handleButton(interaction: ButtonInteraction, meta: CommandExecutionMeta) {
    const extra = meta.get(TypedKeys.CustomIdExtra);
    const result = store.deserialize(extra);

    switch (result.id) {
      case Ids.AgeUpdate:
        await interaction.reply(`Added ${result.data.age} years!`);
        break;

      case Ids.StrengthUpdate:
        await interaction.reply(`Added ${result.data.strength} strength!`);
        break;
    }
  }
}

```

```mdx-code-block
</TabItem>
</Tabs>
```

## ðŸ‘· Creation

You can create a command custom ID codec by either:

* Extending `DefaultCommandCustomIdCodec` from `@framework` (recommended).
* Implementing the `CommandCustomIdCodec` interface from `@core`.

```mdx-code-block
<Tabs>
<TabItem value="Extending DefaultCommandCustomIdCodec">
```

```ts
class MyCommandCustomIdCodec extends DefaultCommandCustomIdCodec {
  // ...
}

const myCodec = new MyCommandCustomIdCodec();

const myBot = Bot.create((bot) => ({
  commands: DefaultCommandManager.create(bot, client, clientBus, { customIdCodec: myCodec }),
}));
```

```mdx-code-block
</TabItem>
<TabItem value="Implementing CommandCustomIdCodec">
```

```ts
class MyCommandCustomIdCodec implements CommandCustomIdCodec {
  // ...
}

const myCodec = new MyCommandCustomIdCodec();

const myBot = Bot.create((bot) => ({
  commands: DefaultCommandManager.create(bot, client, clientBus, { customIdCodec: myCodec }),
}));
```

```mdx-code-block
</TabItem>
</Tabs>
```

