---
title: Ô∏èüë§ Session
---

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

A `Session` is an object that holds the state of an interaction session.

The workflow of a session goes like this:
1. The session is instantiated by some object when an interaction is received.
2. It's passed to `SessionManager#start()`. This ultimately starts the session via `Session#start()`.
3. The session replies to its `SessionStartInteraction`, with components that route back to the session.
4. The user uses one of these components. The bot receives it, sends it to the `SessionManager`, and it's ultimately
routed to `Session#update()`.
5. The session is updated, replying to that new interaction, and the cycle repeats.
6. Eventually the session ends or expires, calling `Session#end()`.
7. The result is extracted via `Session#getResult()`, which is used to [emit the event](../session-bus), and to
[resolve the end promise](../session-promise-repository).

:::tip
To avoid issues, it's recommended that the object that instantiates the session doesn't reply to the interaction.
Instead, that should be done by the session itself (on `Session#start()`).
:::

## üë∑ Creation

You can create a session by either:

* Extending `AbstractSession` from `@framework` (recommended).
* Implementing the `Session` interface from `@core`.

After creating it, start it via `SessionManager#start()`.

```mdx-code-block
<Tabs>
<TabItem value="Extending AbstractSession">
```

```ts
import { AbstractSession, SessionUpdateInteraction } from '@nyx-discord/framework';

class MySession extends AbstractSession {
  public async start() {
    const buttonId = this.buildCustomId();

    const updateButton = new ButtonBuilder()
      .setCustomId(buttonId)
      .setLabel('Update')
      .setStyle(ButtonStyle.Primary);

    await this.startInteraction.reply('Hello!');
  }

  public async end() {
    const reply = await this.startInteraction.fetchReply();
    await reply.edit('Goodbye!');
  }

  protected async handleButton(interaction: SessionUpdateInteraction) {
    await interaction.reply('Hello again!');
  }
}

// Somewhere in your code, like inside a command...

const sessionId = 'mySessionId'; // Ideally randomly generated
const session = new MySession(bot, sessionId, interaction);
await bot.getSessionManager().start(session);
```

```mdx-code-block
</TabItem>
<TabItem value="Implementing Session">
```

```ts
import { Session } from '@nyx-discord/core';

class MySession implements Session {
  // ...
}

const session = new MySession(/** ... */);
await bot.getSessionManager().start(session);
```

```mdx-code-block
</TabItem>
</Tabs>
```

## üìù Updating

A session is "updated" when an interaction whose `customId` property refers to the session is received. The session
is then updated via `Session#update()`, and it's responsible for answering to that interaction.

:::tip
When extending `AbstractSession` you don't need to implement `Session#update()`. By default, it redirects interactions
depending on its type:

* `#handleButton()` for `ButtonInteractions`.
* `#handleSelectMenu()` for `AnySelectMenuInteractions`.
* `#handleModal()` for `ModalMessageModalSubmitInteraction`.

Override these instead, depending on what components you are sending.
:::

When the session is updated, `Session#update()` (or each handle method) must return whether the session's TTL has to be
refreshed or not.

:::note
Returning `true` on every update refreshes the session's TTL when updated, while returning always `false` makes the
TTL to never refresh, like a "timed race" session.
:::

## üí¨ Custom Ids

The `SessionCustomIdCodec` is the object responsible for generating and validating customIds that refer to a session,
called "Session Custom Ids". `AbstractSessions` have protected methods for easier creation of these customIds.

```ts
// highlight-next-line
// Assuming inside a session...

// Creating a simple customId.
const simpleCustomId = this.buildCustomId();

// Creating a customId with extra data.
const extraCustomId = this.buildCustomId('foo');

// To extract the extra string inside an update(), either:
// - Retrieve it from the metadata (this is stored while the session is being resolved):
const extra = metadata.get(TypedKeys.CustomIdExtra);
// - Do it manually, but you'll get the same result as above and waste performance.
const extra = this.codec.deserialize(interaction.customId)!.extra;
```

:::tip
Discord doesn't allow duplicated customIds on a single message, even if they come from different component types.
You can use extras like `'button'`, `'select'`, `'modal'` to avoid that issue.
:::

## üèÜ Result

A session can provide a "result", the type of which is defined by the session's generic argument. When the session ends,
the result obtained via `Session#getResult()` is used to [emit the event](../session-bus), and to
[resolve the end promise](../session-promise-repository).

Use the result to make sessions that "aggregate" some input data from the user, which can then be used in other code.

```ts
class MySession extends AbstractSession<number> {
  // ...

  public end() {
    this.result = 1;
  }
}

// Somewhere in your code, like inside a command...

const sessionId = 'mySessionId'; // Ideally randomly generated
const session = new MySession(bot, sessionId, interaction);
await bot.getSessionManager().start(session);

const endData = await session.getEndPromise();
endData.result; // 1
```

## ‚åõ Session TTL

Once a session starts, it has a given TTL until it expires. When the session is updated, `Session#update()` returns
whether the TTL has to be refreshed or not.

:::note
Returning `true` on every update refreshes the session's TTL when updated, while returning always `false` makes the
TTL to never refresh, like a "timed race" session.
:::

You can specify a TTL:

* Overriding `ttl` when extending `AbstractSession` from `@framework`.
* Returning it on `Session#getTTL()` when implementing `Session` from `@core`.

## üöß Filters

A `SessionFilter` is an object that can be used to filter out session starts (`SessionStartFilter`)
or updates (`SessionUpdateFilter`). They are provided by the session, via `Session#getStartFilter()` and
`Session#getUpdateFilter()`.

To add a filter to your session, first create the filter:

* Extending `AbstractSessionStartFilter` or `AbstractSessionUpdateFilter` from `@framework` (recommended).
* Implementing the `SessionStartFilter` or `SessionUpdateFilter` interface from `@core`.

After creating it, add it to your session class:

* Overriding `startFilter` or `updateFilter` when extending `AbstractSession` from `@framework`.
* Returning it on `Session#getStartFilter()` or `Session#getUpdateFilter()` when implementing `Session` from `@core`.

:::note
For more information on filters, check the [üõ°Ô∏è Session Interception](../session-interception) documentation.
:::
